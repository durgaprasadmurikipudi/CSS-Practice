HTML is to structure the content of the web page.
CSS is to syle the content of the web page. It can also change the positioning of the elements. 


CSS was first introduced in 1996. We refer to this as CSS version 1.

This was the first time you finally got tools to improve the look of your web page.

Now, only two years later, we got CSS version 2. The latest

version of CSS, actually CSS version 3,

is the one this course uses and it's still in development.

Isn't that strange...?

Will there ever be a version 4 at some point in time?

No. We'll never get a CSS version 4 because with CSS version 3, the concept or the approach toward

CSS (towards the development of CSS) changed. Rather than focusing on different versions, they've now

split up CSS into a couple of modules which are organized by the feature they cover.

So, things like modules on coloring text, modules which focus on shadows and modules which focus on

animations. We've got different versions of these modules and new modules and module versions will

be continuously added in the future;

simply to keep up with modern developments and to keep CSS dynamic.

The important takeaway for you is to know that CSS simply keeps evolving.

It still is under active development and we will see new and improved features in the future too; simply

to keep up with the general evolving nature of web development itself.

Basic things:

How to add CSS to HTML ?
How to set up CSS rules ?
What are selctors, properties and values.
What are conflicting styles ?


There are mainly 3 ways to add css:

1. Inline:

suppose you have a <p> element, how do you set its background color to blue?
In inline way you can do it like this: 
<p style="background: blue"> Hey hi!</p>
 and you're done.

There are 2 advantages of inline styling, first thing is readability, if you have many nested elements, then the style
resulted via cascading from the parent element cannot be calculated and hard to understand.

second, it doesn't scale. If you want to change like some 10 properties on a single element, soon it becomes ugly.

2. By writing in style tags in head section.

<head>
    <style>
        p {
            background: blue;
        }
    </style>
</head>

In head section, you can actually include a style section, where you can write the styles.
syntax is :

    <selector> {
        ...style rules
    }

    you open a selector, that is either tag names in html or id's of any html element or a combination of above.
    you write all the styles that you want to apply.

Down side, Fro above 2 styles, the html file size increases, even if style did not change, and only html content changed,
every time there is a request for new html, the old style rules still come.

This causes additional loading time.

3. Writing styles in a seperate file with extension .css, and laoding it in HTML page as below:

<head>
    <link rel="stylesheet" href="<filename>.css" />
</head>

This way, css files can be cached.

color -> this si some style that changes the color of text in an element.
font-family -> there are different fonts on how text will look. Ex: are Times, Courier.

if you mention sans-serif as font-family, its actually a special key word, meaning it will default to whatever the browser default
font setting is.

If it has courier as default setting, then sans-serif will refer to it and so on.


so far we used element selectors, but we have different selectors as well..

class selectors:
 This is a concept associated with css rather than html.
 You declare a class like below:

 .<class-name> {

 }

 a class always start with '.', now if we mention class="<some-class-name>" in any html tag, that tag will have all the styles
 defined in <some-class-name> class. You can set a single class to any number of elements, thus declaring a class
 also encourages reusability of style.

 A element can also have multiple classes.

 ID selectors.
 An id is a html attribute that is unnique all over the html conent. you assigna a unique value to a css element by help of this
 id attribute.

 now if you want to apply css style to some element having particular id value, you declare the css as below:

 #<id-vaue> {
     ...styles
 }
  A note on id, you can actually append at the end of the url #<id-name> and you can directly jump over there after loading the page.

 Attribute selectors:

 Every element has some attributes that add some meta dat to html element or modify the behavior of element.
  for example disabled is an attribute that disabled the field. commonly used on input.
 ex: <button disabled></button>, here disabled is an attribute.

 if you want to apply css style to all the elements having a particular attribute, then you declare css as follows :

 [<attribute-name>] {
     ...style
 }

 cascading styles and specificity:

 AS we already side, we can assign multiple classes to same element,
 then if both css classes has some same style property.. which would get applied first, common sense is that, whatever comes
 last would take into effect and that is right.

 Even in the external style sheets, if 2 same selectors were defined styles, the last selector styles would override the first 
 selector.

 One more thing, 

 In order of priority the below styles are applied:

 Inline styles,
 #ID selectors,
 .class, :pseudo-class and [attribute] selectors,
 <Tag> and ::pseudo-element selectors.

 even if we dont mention some styles, there are automatically present, example.. h1 has by default { display: block } style.
 These will be first applied adn then overriden as mentioned by the above selectors.

 Intro to combinators:

 now if you want to apply all h1 elements inside a specific id, you can do as below:

 #<id-name> h1 {
     ...styles
 }

 now if you already have a generic h1 selector, still all the h1 elements inside that specific id element will all have this 
 special h1 selector. 

 So that rule will dominate which has more information on how to select the elements over a vast collection of elements present in the 
 body tag.

 Here rather than generic selector, h1 , <id-name> h1 is a mroe specific selector and has more information and so it will dominate.


 #ID selectors,
 .class, :pseudo-class and [attribute] selectors,
 <Tag> and ::pseudo-element selectors

 the specificity is used to resolve conflicts when there are multiple styles applied to same element.

Combinators in general will allow you to specify much more information on how to select elements and be more clear about our rules,
there are 4 types of combinators:

+ Adjacent sibling: 
    ex syntax: h1 + p => this implies that whenever a pair comes like p immediately follwing h1 comes up, or that whenever p is such
    that it is immediately adjacent to h1, then the rules mentioned in that style will be applied on every such p tag or element.
    Remember that both have to be in the same level, not a parent child relation ship. I.e, they share the same parent.
    you could use multiple adjacent rule, like h1 + p + a, that says, a should follow p and that should immediately follow h1
    and then only this rule will be applied to that 'a' element.


~ General sibling : h1 ~ p, is same as that of above except that, p need not immediately follow h1, it is enough that they
  both share the same parent.


> child : h1 > p, any p tag that is a direct child(not just child) to h1 tag, then the style will be applied. IT can also be applied
to multiple like h1 > p > a.


'space' descendant: ex: h1 p, here all the p elements which are childs of h1 will get the style, it doesnt matter, if they are 
direct child or not.

 How to know which has how much specificity, or in general how to resolve specificity ?

3 number system 
#-#-#

first position is filled with 1 if a id selector acts on that element else 0,
second position should be filled with 1 if a class selector acts on that element,
third position should be filled with 1 if a tag selector  or ::pseudo-element selector.

if there are 2 class selectors acting, fill the second position with 2, and so on for all styles.
the first position has highest precedence and the last position has lowest precedence.

ex: p .<some-class>  has specificity 0-1-1
and #<some-id> p has specificity 1-0-1,
and li+li+li has specificity 0-0-3

so if the above 3 styles apply on some element in html, then the one with specificity 1-0-1 wins.

***** Also if both has same specificity like 0-1-1 and 0-1-1, then that style will win which is last present in the stylesheet.
becuase it will override the already applied one.

Points to remember:
PArent styles are generally inherited.
Multiple rules can apply to one element.
Specificity resolves "multiple rules" conflict.
Inheritance defaults can be changed.

2. Working with Boxes:
========================

Every element in HTML is treated as a box in CSS. Each element has 3 layers: Padding, Border, Margin.

Every element will fall into three categories.
Block element, Inline-Block, Inline as we know.

When two block elements are present, lets say p1 and p2 representing two paragraph elements.
If p1 has margin 20px and p2 has margin 20px, then margin-bottom and margin-top of both p1 and p2 respectively will be merged into
one.
This is called margin-collapsing. So due to the concept of margin-collapsing distance netween the 2 block elements will be 
20px isntead of 40 px.

If p1 has 21 px and p2 has 20 px, then the distance between the 2 elements will be 21px.
So the bigger margin wins.

You can dive deeply into it with the help of the following awesome article: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing

There, three base cases are described:

Adjacent siblings which both have margins
A parent which holds one or more child elements where the first and/ or last (or the only) child has margins
An element without content, padding, border and height
Let's explore these cases:

1. Adjacent Siblings

In this case, the first element might have a margin of 10px  (on all sides let's say) and the second one has 5px  (or 20px  - the values don't matter).

CSS will collapse the margins and only add the bigger one between the elements. So if we got margins of 10px  and 5px , a 10px  margin would be added between the elements?

2. A parent with children that have a margin

To be precise, the first and/ or last or the only child has to have margins (top and/ or bottom). In that case, the parent elements margin will collapse with the child element(s)' margins. Again, the bigger margin wins and will be applied to the parent element.

If the parent element has padding, inline content (other than the child elements) or a border, this behavior should not occur, the child margin will instead be added to the content of the wrapping parent element.

3. An empty element with margins

This case probably doesn't occur that often but if you got an element with no content, no padding, no border and no height, then the top and bottom margin will be merged into one single margin. Again, the bigger one wins.

Seperate proprties and Short-hand proeprties:
Some CSS style properties have some shorthand notations:

for example: Border and margin.

Border properties :

border-width: 2px;
border-style: dashed | solid;
border-color: black;

Shorthand notation for the above 3 props:

border: 2px solid black;

Same with Margin:

Margin properties:

margin-top: 5px;
margin-right: 5px:
margin-bottom: 5px;
margin-left: 5px;

Different shorthand notations for the above:

margin: 5px; /* 5px on all sides. */
margin: 5px 5px; /* 5px on top and bottom <space> 5px on right and left */
margin: 5px 5px 5px 5px; /* top right bottom left */

if you want to set all sides of margin to 5px except the top which you want to set it to 7px, you acn do it by the follwing.

margin: 5px;
margin-top: 7px; /* since it is parsed the last, so this style will be applied. */

We can also set height and width on the block and inline-block elements.

By default, block elements occupy all the available width.

height is calculated in a weird way when we use % units.

First HTML calculates the height as big as it content is, thats it. So if you have 3 lines of text, then it will not occupy
the whole body of browser, but jsut the space that 3 lines will occupy.

So if a p(block) element has one line of text, with no margin and padding, then it will occupy only 1 line of space.
Even if you explicitly mention, height: 100%, it has no effect. It will still occupy 1 line of space.
Now if you set HTML height has some 700px, then that p elment will also occupy 700px.
Else, if you hardcode it to use 700 px for p element again it will occupy 700 px height.

So generally all elements will occupy only that space, which it contents allow it to, unless you use the units px.
Width, but can reduce its width with the use of %. It will occupy the whole available width of browser by default, and so the width
whether we use % or px units, works as expected.

Now the height is always calculated, excluded of padding, border and margin.
If you want to include padding and border also in height and width calculation, then we have to set the css style,
box-sizing: border-box;
The default value of the above is content-box;

There is no way to include, margin also in the width and height calculation, so if you set widht: 100% and set some margin without
border-box calculation, then the border and padding disappears on the right side.

Now if you set border-box property to body element, it will not directly affect all the child elements..
It will just set the style to body. It will just override body's default value. The rest block elements height and width 
calcualtion will be again, conent-box-sizing. We use css for the same reason, to specify a specific style or to override the browser defaults. 

Becuase for every element, browser sets some default styles and border-box is one among them. For all block elements, it will set to content-box style for box-sizing. Some styles are inherited from its body.
We also use css to override the inherited values as well.

Now that broswer sets default every block category elemetn box-sizing to content-box, we got to set it to border-box manually.

* {
    box-sizing: border-box;
}

This way we will now override all the broswer defaults.

Also, every inline-block element will have default values for margin and padding added by browser. And to reset it manually add
margin:0 and padding: 0;

Weird behavior of inline:
When there are two inline block elements, then in html page code, even if there is new line character, that also takes space and can 
sometimes change style if elements arrangement is arranged such that, each pixel is counted. Because we normally tend to forget
the space occupied by this new line characters.

One thing we can do is add comments connecting to the inline block elements like below:

<p>
--</p><!-- this comment is remving space/new-line character yet makes legible by seperating elements into  their own new lines in code text.
--><p>
...
</p>


else dont forget to add the space taken by this character also.

Pseudo Elements and Pseudo Classes:

Pseudo class -> syntax -> :<class-name> -> defines the style of a special state of an element.

ex: -> a:hover, div:hover

Pseudo elements -> syntax -> ::<element-name> defines the style of a specific part of an element.

ex: p::first-line {
    color: red;
}

Makes all first lines of paragraph text red.

Grouping selectors:

if you have two styles like below,

.main-nav__item > a:hover {
    color:white;
}

.main-nav__item > a:active {
    color:white;
}

you can actually group them like below

.main-nav__item > a:hover,
.main-nav__item > a:active  {
    color:white;
}

the 2 .main-nav__item > a:hover, .main-nav__item > a:active are not combinators and are not related in any way,
just that they share the same declaration set.

What happens when we apply two classes on a same element ?

Then that class declaration which appears last in the css code file wins.

So it doesn't matter in which order you use them while applying, but it does matter in which order you declare the definition
of the classes.

special mention - syntax :

<Tag>.<Class_Name>

selects all that specific <Tag> with the mentioned <Class-Name>.

CSS Class selectors vs ID selectors:
====================================

CSS Class should be our first pick. They are reusable, allows you to "mark" and name things for styling purposes.
Acts as an identifier for particular style. Even if you use that class only once, its ok to declare it and using a class is rarely 
wrong.

ID selectors on the other hand, are used to style for specific purposes..They also indicate non-css meaning e.g. on page link..
you can got to specific element by appending that id in url. So ID plays a dual role, where as classes are singly dedicated to 
styling purposes and hence use classes for styling purposes.

!important:

This is mentioned to apply a style attribute, overriding all specificity rules.

syntax: 

p {
    color: #ccc !important; /* This will apply regardless of any css rule precedence */
    background: white; 
}

:not pseudo selector:

ex: :not(p) {
    color: red;
}

selects all tags that is not p and applies color red.

a:not( .active) {
    color: blue;
}

selects all anchor tags that do not have class active and applies color blue.

a :not(.active) {
    color: blue;
}

selects all child elements of all anchor tags that do not have class active.

Can I use.com tells u which features of css and javascript are supported by broswers. It also mentions partial support and
total reach.


See buttons have lots of default options, more over the text present in it sometimes can be lot different from what we have.
Generally to style buttons we declare a "button" class that has all the basic look of a button. Thne if you want to modify 
any button you kust declare a modifier class for existing button class.

Also, Hover effects look good when you use contrast color complement technique.
That means, if button background color is green and text color is white, while hovering it.. reverse it, make text color green
and background color white. But make the border color consistent across the hover effects to show a clear presence of button.
Also to make the buttom mroe standout so that it looks like a clickable, you have to contrast its color even more.
For example if general background color around button is green, then make the buttons background color as darkgreen.

Standout technique is the same. If you have 2 components and you want to highlight one among the two.
Set the bg color of non-important one to light-green(example) and important one to green color. Also set the box offset.
This light-normal color combination, helps you to stand out.
Also good color for box-offset is gray color with transperency 0.5.

Also while designing card like structures use text-alighment to center. Also set cards vertical alignment to center.

Even for every list item, you can mention a class, this is fast rendering and celan approach. Probably sometimes little extra 
text. This way employ class based design as much as you can.

By default some browsers add a blue border when an element is focussed.
If you want to remove it, then set out-line proeprty of it to none. That too under :focus pseudo class.

First things first;

When you remove the list style, you autmoatically set their margin to 0 and padding to 0.
Also set vertical-align to be center.

Also when you set display to inline-block for any element, make sure to mention the width accordingly.
If there are 3 inline elements and you want to position them side by side, set each of its width to 30%;

If you want to change a div to round card, 
set its height and width to same value, also set border-radius to 50%.

An old lesson, setting the margin to auto sets the element to sit at the center of the parent element.

Also, we can actually set on UL tag, text-align property to center and get the text elements aligned to center.

Always set display to block while dealing with inline elements as block elements.

If you use float property on any block element, then the below block element if any exists will wrap around the floated element.
To fix this, an empty div element is usually placed below the element to be floated and will be applied style property, clear: both;

Positioning:
============

By default all the elements in the HTML have position proeprty set to static.

We can position the elements anywhere in 8 directions (TOP, BOTTOM, RIGHT, LEFT, TOP-LEFT..) from the current element postiion.

Position property values:

Fixed:
------

The fixed places the element relative to the viewport. Change position property to absolute, and apply any of the direction flow 
in units px or %?.

The element will be placed there. The elements below it occupy the space of this fixed element :P. this fixed element floats in air.

Also, by applying this 2 preoprties the element will become inline-block element.
Whether it is a block or inline element, it becomes - inline-block element.
By becoming inline-block element, its initial width if not set, will wrap its width size according to content.

Also, to set a background image, we can actually declare an empty div element. Via css we can set its background to an image.
Although its widht and height is set to 100% it would not take any effect. if you manually set height in weight in px, it will 
occupy space as block element. So to become truly background z-index should be applied. For this to take in effect, the element
should also have the position property set to a value other thna default value 'static'.

By default z-index value will be 0/auto. so if you set any element value greater than 0 or auto value, it will be top of that 
elements where its positioned.

if two different element have same z-index value then that is declared last in the html element will be on top. by default all z-index
set elemetns will have position set to different value other than 'static', so they kind of float in air. so if two elements
position is overlapped and they have the same z-index value, that element will be on top which cones last in html code file.

lastly z index value can range from any negative number to any positive number range.

Absolute:
---------

Absolute and Fixed both behave in the same way. They both take the elements out of the document flow and position the elements
in the position parameters specified.

The key difference is with what this position parameters are calculated.., for fixed it is always the viewport and for absolute its the
nearest enclosing parent element which has the position property value set to a value different than 'static'. If none exists
then its viewport again.

lets discuss a problem scenario,
 there are 3 div elements each are like atleast 240 px in height.(just mentioning height to eastablish the fact that they occupy a 
 considerable space. ) Now if you want to keep a badge on first div element to mention its recommended or to keep some
 emphasis on it. so you wanna keep that badge on top-right corner.. Then how would you achieve it.? Even under responsive design ?

One easy way to achieve is using position properties. 

Now if you apply position - fixed  to  badge, it will move along with the scrolling.
if you apply absolute such that its positioning is set w.r.t to target div element, it would work only when this div elements position
property is set only to different value other than static.

If we apply fixed or absolute to div elements this would all be remvoed out of documetn flow and come on top of one another..
so how ?

Keep positioning property 'relative' to those div elements, now just apply position property 'absolute' to badge div element and keep
top:0, right: 0 in its properties.

It will happily set its position in first div element in top-right corner and our desired result would be achieved.

Actually if we have a haeader in the same page and it is positioned with the 'fixed' property then, it will be overriden by this 3
div elements as you scroll, to fix it, put z-index: 1 for header.

Relative:
---------

Relatively positioned elements are not taken out of the document flow., and if you mention top or left or son on.. on it, then it will
move respectively to its curent position, the space left by it will not be occupied by any other below elements. You can even make 
it go out of the current enclosing element.

Also, you can make it hidden as soon as the element move out of the enclosing parent elment by adding property to parent,
overflow: hidden;

But if your parent is body element, you have to add it in both HTML element and body element , to make it work.

if you just declare like this 
body {
    overflow: hidden;
}

it will be simply be passed into html element.
but if you declare in both html and boyd, the declaration stays in the body as html already has it and thus works.
Thisi s the default behaviour of css and nothing can be done except declaring in both places.

Sticky:
-------

The sticky position along with some property, top:20 or any other, will behave like a relative element at the beginning and then,
behaves likes a fixed positioned elemetn as soon as the element when scrolled is at distance 20px from the top or less w.r.t to the viewport. Tt will
move along the scrolling till its parent element is fully scrolled off and once scrolled off or top:20 property (or any other direction property) you set is not satisfied, it will move back to its original position liek a relatively positioned element.

The top or any other direction property that is set will always work w.r.t to Viewport.

Stacking context:
-----------------

lets say we have 3 div elements, with ids div1, div2 and div3 respectively.
Now also lets say we have 3 other div elements in div2 as well with id's div21, div22, div23.

Then, if all the position property is fixed means, div 3 will be on top of div2 and di2 will be on top of d1.
Set d2 z index as 100, then it will be on top of all divs.
Now if you set div3 z-index as 1000, obviously it will be on top of them.
but set d21 z index to be 10000, still it wont surpass div3, since its parent z-index is only 100. this is called stacking context.

Stacking context referes to z-index behaviour among siblings and its children.

children can never suprass its enclosing parent through z-index. Neither can go beneath.

Background-size property w.r.t to Images:
=========================================

Background-size: 
----------------
This can be mention in terms of pixels and it will be occuping that space alone.
If you mention only one value in px, it will then apply it to widht and height will be adjusted.
If you mention 2 values in px, then width and height will respectively take that values in px.
If necessary iamge will be coerced or zoomed in.

If you mention background-size in % and say 100% for both width and height, it will take that image part to fill the container,
if its too big, or zoom out if its smaller than the container. 
simply putting value 'cover' also does that.

A value of 'contain' acts in when the image is too big and sets its aspect ratio such that it will be smaller than the container
and if possible as big as the container ?

Background-repeat: 
------------------
no-repeat, repeat-x and repeat-y. If either the image is small or made small by background-size repeat property,
then it could be made to repeat or no repeat. repeat-x and repeat-y are values to make it repeat along particular axis.

background-position: 
--------------------
This is how you can crop the image..
A simple value of center, displays the central part of image.
Accepted values are : 
left top -display starting from left and top along x-axis and y-axis respectively.
left center - display starting from left and center along x-axis and y-axis respectively.
left bottom - and so on..
right top
right center
right bottom
center top
center center
center bottom

If you only specify one keyword, the other value will be "center"

Also, you can mention the above values much more fluidly in %

A value of 10% 10% means, start from left - 10% and top 10%, means about 10% of the full image from left will be cropped and 
10% from top of full image will be cropped, and then it starts covering the whole container. if it fits well and good, else
the remaining parts will all be cropped.

Thus way you can mention starting from left and top, how much if excess image should be cropped. If its fits no cropping, if it doesn't fit happy cropping!

if you mention value 100% from left, all the right part will be displayed in the container, and excessive width occupied by image will be cropped only from the left side.

Also you can mix in left and % values like below:
background-position: left 50% bottom 50%;
so 50% of left to be cropped if any excess exists and same with the bottom.

But this behaves differently when you mention this properties value in px. If you mention the value 10px and 20px, then it will move the image along the x-axis by 10px and along the y-axis by 20px.

Setting up an icon:
-------------------

Now by default image occupies whatever height it can regardless of the container it is present.
So if you wanna set the height or width of the image such that it is contained within the container, you hav to explicitly 
mention the height: 100% on the image to occupy the whole available heigh of container. Images aspect ratio is by default adjsted by browser as soon as you change its height or width. i.e, if its height is adjusted then the width will automatically get adjusted. If its width is adjusted its height will autmoatically be adjsuted.

Now if the image is present in an inline element, make it inline-block, else by default image will regain its to original height and width. So to fix it make it inline-block, adjsut its height and width as wanted, then set the image height to 100% to make it
occupy only containers height. Width as expected will be automatically gets adjusted.

To make the images and text, side by side: make both div's inline - blocks, adjust their width such that they cocupy the container width and also set vertical-align : middle, such that both text appears at the mid.

Also make sure that vertical align-top for the image alone if you see any whitespace for image at the bottom, or jsut make the image alone a block element to make the whtiespace at the bottom disappear.

Linear-gradient:
----------------

To just display a rainbow of colors..

syntax:

background-image: linear-gradient(180deg, red, blue, ... /*as many colors as you want*/);

background-image: linear-gradient(to bottom/top/ left bottom/ left top, red, blue, ... /*as many colors as you want*/);
.. mentioning from which direction this should start..

background-image: linear-gradient(to bottom/top/ left bottom/ left top, red, blue, rgba(0,0,0,0.5));
can even use rgba colors..

background-image: linear-gradient(to bottom/top/ left bottom/ left top, red, transparent);
can take value transparent

background-image: linear-gradient(to bottom/top/ left bottom/ left top, red 60%, blue, rgba(0,0,0,0.5));
can mention which color should occupy the majority space. or we can direct how much each color should occupy.

There is also radial-gradient:

radial-gradient(circle/ellipse at top [left]/ bottom/ 20% 50%/.., );

Stacking multiple backgrounds:
-----------------------------

Using the background shorthand proeprty, each aprameter to it will be a backgorund.
ex: background: linear-gradient(to top, rgba(150,150,150,0.6), transparent), url(./background.jpg) left 10% bottom 20% no-repeat boder-box;

Now from bottom to top there will be a thin layer of color mentioned in linear-gradient and then thei mage will be visible under
its influence.

Filters:
--------

Adding gray scale, increasing brightness and contrast of an Image and so on..

To make an image compeltely greyish , try it its awesome..

filter: grayscale(100%); add it to the class that loads background image.

Also, padding on a fixed size elements reduces the space occupied by elements inside it.

Units:
======

Whats wrong with using pixels.?

See if you mention 20px font size for a paragraph, then if the user increases zoom size in broswer for more readability, then that text doenot get zoomed in which is a problem. If you basically leave the font size decided by broswer, by using broswer defaults,
then you dont have much a choice..

Units present in CSS:

pixels: px

percentages: %

root em: rem

em : em

viewport height: vh

viewport width: vw

Which properties mostly use units, in box-model ,they are height, width, margin, padding, border, when you use position property.. then top, bottom, left, right also comes into picture.

3 categories :
==============

Absolute length :
-----------------
These basically ignore user settigns like if they oincrease the font etc..

The units belong to these are px, cm, mm..

Viewpot length:
---------------
Adjust to current viewport.

most popular units are vh, vw, vmin, vmax..

Font-relative lengths:
-----------------------

Adjust to default font size mentioned by browser.

Most popular units are : rem, em..

% is altogehter a different category, we will dive into it more in latter part..

When we use position property fixed for an element, its parent element is viewport.

Also, when using position property absolute, and you use % unit, then it will refer to the enclosing nearest parent element under the condition that its position property is set to a different value that 'static'.
How much of length will it refer ? the content + padding of the parent. If it has no parent such, then it will be viewport width.

When position property is set to 'static', or 'relative'.., then its parent is the closest enclosing block level element.
Even it has enclosing element - an inline block then, it will still derive its width from the closest enclosing block element.
The width of the content occupied by the enclosing block element.

By default for an empty div element with property height 100% will not let it occupy the full screen if its position property is set to 'static' or 'relative'.

For that to occur, a parent element should the explicit height defined either in % or pixels. Else it will be 0, as the height is dynamically calculated after the DOM is rendered. And while this element is parsed as it has no data, it will have height 0.

So to summarise, for statc/relative elements for height: 1005 to work, make sure allthe ancestors have height value declared.
For position and fixed, this is not necessary and also if you use vw or vh or px units, heigth will work again as expected.

Margin collapsing w.r.t to Positioning concept:
-----------------------------------------------

 Lets say you positioned an  div with notning but a background having gray scale of 50%, you pisitioned it above all the elemetns lets say.

Unless you mention the top/bottom/left/right explicitly.. by default it would not cover all the available width and height.

Although these fixed and absolute elements have a higher z-index, the margin-collapsing phenomenon would still occur and the margin of the element directly below it and the current element's margin is taken and the one which has highest margin wins, and that will be respected by both this fixed postion-fixed element and the element directly below it.

since positioend elements can be placed anywhere, when top, bottom, left, rigth properties are mentioned, this margin and margin-collapsing is altogehter ignored.

Relative - z-index appearing scenario: 
--------------------------------------
Z-index by defautl appears for Fixed, Absolute, Sticky and would appear for relative only when its moved some what from its current position.

Syntactically, a relatively element acquires a positive z-index value from browser only when some one or some or all the  properties like top/bottom/left/right are mentioned. 

Max-width & min-width:
----------------------
Define this properties on a element, like min-width: 250px, then the element size will never decrease than 250px. If viewed on a screen less than 250 px, then the element will be cropped from layout of the same element with base width 250px and will be 
displayed whatever that gets perfectly fit after cropping.

Same with max-width.

These properties should always be used in conjunction with width proeprty or height property.

REM & EM:
---------

A basic em unit is 16 pixels - accordign to gChrome basic settings,

now if the div element font-size if is declared to have 1.2 em, then the text inside will 19.2px size.
Now in the same div element, if there is anotehr h1 element and has font size 2em, then its font size would be 38.4px rather than 32px, this is becuase of the use of em. And so the use of em in nested elements will soon enough results in a mess and so it should be used judiciously. Better use it only for child elements and dont nest it much.

Rather if you use rem at both places, then div font size will 19.2 px and h1 element will be 32px as rem wil straight away will refer the root size always. Also rem is recently introduced.. but browser size is decent. 

So basically maintaing the font-sizes in rem usually helps in user accesibility and consistently increases the text over present in all elements as user zooms in or zooms out of the broswer.

if you use it in padding amd margin's also, then pretty much there will not be any breakage in the generaly style of the website as the user zooms in or zooms out. But height and width calcualtion need not be done in this font-size units for obvious reasons.

vh, vw -- vmin, vmax:
---------------------

vh refers to viewport height.
100 vh means 100% of viewport height and 1 vh - only 1%.

vw refers to viewport weight.

vmin - refers to minimum of viewport height and viewport weight. ( or min of current browser height and width)


vmax - refers to max of viewport height and viewport weight. ( or max of current browser height and width).

sometimes usage of vw or vh can sometiems display scroll bars in wondows machines and you can actually hide thm with css.
After adding vw , you probably saw that the scrollbars appeared in case you are working on Windows. This happens as using vw  on Windows does not include the scrollbars - vw: 100  is  equal to 100% of the viewport width + the scrollbars. On the Mac this is not an issue, but when using Windows it is as the scrollbars are displayed by default.

In case you don't want to display these scrollbars, you can use one of these solutions:

- Use width: 100%  instead of vw: 100

- Add overflow-x: hidden;  to the body selector in the shared.css file to hide the horizontal scrollbar (or overflow-y: hidden  to hide the vertical scrollbar)

Alternatively you could also use the ::-webkit-scrollbar pseudo element. Simply add the following code to the shared.css file:

body: :-webkit-scrollbar {
    width: 0
}
To make sure this works correctly on different browsers, you have to add additional code to it. This blog post
https://blogs.msdn.microsoft.com/kurlak/2013/11/03/hiding-vertical-scrollbars-with-pure-css-in-chrome-ie-6-firefox-opera-and-safari/

 nicely summarizes all the code needed right here.

Make sure to follow these approaches in case you don't want to display the scrollbars on Windows machines.

Choosing the right unit:
------------------------

Font-size: Rem, em => child only.
padding, margin: rem;
border: px;
width & height: % in general, but for a specific case to do with viewport, then vw and vh.
top, bottom, left, right - %.

Also, using auto can center elements only for block/inline-block elements which already have been assigned some width.

Auto is also a measurement.

































